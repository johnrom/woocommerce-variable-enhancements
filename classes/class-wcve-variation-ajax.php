<?php

class WCVE_Variation_Ajax {
    private $plugin;

    // %1$d: product_id
    private static $product_variation_transient_pattern = 'wcve_product_ajax_variation_%1$d';
    private static $product_variations_version_transient_name = 'wcve_product_ajax_variations';

    public function __construct( $plugin ) {
        $this->plugin = $plugin;

        add_filter( 'woocommerce_ajax_variation_threshold', array( $this, 'disable_variation_threshold' ), 10, 2 );
        add_filter( 'woocommerce_pre_get_available_variations', array( $this, 'prefetch_available_variations' ), 10, 3 );
    }

    public function disable_variation_threshold( $threshold, $product ) {
        return count( $product->get_children() ) + 1;
    }

    private function version_matches_cache( $version, $product_id ) {
        $cached_versions = get_transient( self::$product_variations_version_transient_name );
        $cached_version = ! empty( $cached_versions[ $product_id ] )
                ? $cached_versions[ $product_id ]
                : '';

        return ! empty( $cached_version ) && $cached_versions[ $product_id ] === $version;
    }

    public function prefetch_available_variations( $available_variations, $product, $data_store ) {
        $product_id = $product->get_id();
		$transient_name = sprintf( self::$product_variation_transient_pattern, $product_id );
		$available_variations = get_transient( $transient_name );

        if (
            empty( $available_variations['version'] ) ||
            ! $this->version_matches_cache( $available_variations['version'], $product_id )
        ) {
            $available_variations = false;

            // imagine this: as_schedule_single_event( time(), 'recursively_build_variations_caches' ) );
        }

        return $available_variations;
    }
}
